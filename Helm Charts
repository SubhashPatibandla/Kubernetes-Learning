# What is Helm ?

Helm is a package manager for kubernetes, similar to apt package manager in linux.

usually we run Sudo apt update or sudo apt install nginx or phython3 etc inorder to install packages of nginx or phython3 as required.

similarly helm will help you to download the packages into kubernetes cluster, install them and update them as required.


what is repo in helm ?

There are some repositories available in the market which are helpful to get some commonly used charts in order to install , update or delete.

let's say you want to install nginx into one kubernetes cluster.

now first will add the repository to helm by using below command :

helm repo add bitnami.com

after adding the repo, will run the below command to install nginx :

helm install nginxv1 bitnami/nginx

in the above command, nginxv1 is the name of the package you wanted to name with.

bitnami/nginx is like repo/chart which you have downloaded/installed.

-- that's how helm is useful similar to apt in linux.

# then how the helm is useful at real world production level ?

usually we may need different setups at different environments.

so we can't write manifest files again and again for each microservice at every environment like dev, testing and prod.

so in order to make those manifest files reusable, we can update the data of manifest files as variable. 

and we can configure the values in the values.yaml separately for dev, testing and prod.

inorder to get clear understanding, please go through the below steps after writing manifest files for any microservice:

we’ll go step-by-step and start from zero, assuming you only have Kubernetes manifest files for your microservice called payment, and you want to make it into a Helm chart so it’s reusable and easy to deploy.

I’ll explain every step clearly.


---

Step 1 — Understand Your Starting Point

You currently have something like this:

payment-deployment.yaml  
payment-service.yaml  
payment-ingress.yaml

These are static Kubernetes manifests.
They work, but:

They’re not reusable for different environments

You can’t easily change configurations without editing files

No versioning or package management


Goal → Convert these manifests into a Helm chart.


---

Step 2 — Install Helm

Make sure Helm is installed on your system.

helm version

If not installed, follow instructions:

# For Linux
curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

Verify:

helm version


---

Step 3 — Create a New Chart Directory

Helm has a command to scaffold a chart for you.

helm create payment

This creates:

payment/
├── Chart.yaml
├── values.yaml
├── charts/
└── templates/
    ├── deployment.yaml
    ├── service.yaml
    ├── ingress.yaml
    ├── hpa.yaml
    ├── _helpers.tpl

What these files mean:

Chart.yaml → Chart metadata

values.yaml → Default configuration values (replicas, image, ports, etc.)

templates/ → Kubernetes YAML templates

charts/ → Sub-charts (dependencies)



---

Step 4 — Copy Your Existing Manifest Content

Open your existing manifests and copy their content into the generated Helm templates.

Example:

Copy payment-deployment.yaml into payment/templates/deployment.yaml

Copy payment-service.yaml into payment/templates/service.yaml

Copy payment-ingress.yaml into payment/templates/ingress.yaml


At this point, your Helm chart has exact same manifests as before, but still static (no values replaced).


---

Step 5 — Replace Static Values with Variables

We replace fixed values in templates with placeholders that refer to values.yaml.

Example before (deployment.yaml):

replicas: 2
image: payment-service:v1.0.0
containerPort: 8080

Replace with:

replicas: {{ .Values.replicaCount }}
image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"
containerPort: {{ .Values.service.port }}

Now these values come from values.yaml.


---

Step 6 — Update values.yaml

This is where you define defaults for your payment chart.

Example:

replicaCount: 2

image:
  repository: myrepo/payment-service
  tag: v1.0.0

service:
  type: ClusterIP
  port: 8080

ingress:
  enabled: true
  hosts:
    - host: payment.example.com
      paths:
        - path: /
          pathType: ImplementationSpecific


---

Step 7 — Clean Up Templates

Remove unnecessary hardcoded values and make templates generic.

Example:

Deployment.yaml → no hardcoded image tag

Service.yaml → no fixed ports

Ingress.yaml → read host/path from values.yaml


This allows the chart to be reusable for multiple environments without editing templates.


---

Step 8 — Test the Chart Locally

Run:

helm install payment-test ./payment --dry-run --debug

This will:

Render your templates using values.yaml

Show generated Kubernetes manifests

Not actually deploy anything


Check for errors and fix them.


---

Step 9 — Deploy the Chart to Kubernetes

helm install payment ./payment

This will:

Create a release called payment

Render templates with values.yaml

Deploy payment microservice with Kubernetes


Check deployment:

kubectl get pods
kubectl get svc
kubectl get ingress


---

Step 10 — Override Values for Different Environments

Instead of editing values.yaml directly, create environment-specific values files.

Example:

values-dev.yaml
values-prod.yaml

Run:

helm install payment-dev ./payment -f values-dev.yaml
helm install payment-prod ./payment -f values-prod.yaml

This keeps your Helm chart reusable.


---

Step 11 — Upgrade / Rollback

If you change the chart (image version, replica count, ports), run:

helm upgrade payment ./payment -f values-prod.yaml

Rollback if needed:

helm rollback payment 1


---

Step 12 — Package the Chart (Optional)

Package your chart for reuse:

helm package ./payment

This creates:

payment-1.0.0.tgz

You can then share this chart file or store it in a Helm repository.


---

Summary Table

Step	Action

1	Install Helm
2	Create chart (helm create payment)
3	Copy manifests to templates/
4	Replace static values with template variables
5	Update values.yaml
6	Test chart locally (helm install --dry-run)
7	Deploy chart (helm install)
8	Override values for different environments
9	Upgrade / rollback releases
10	Package chart

#how to rollback your production environment to a previous version using Helm, step-by-step.


---

Step 1 — Understand Helm Rollback

When you deploy with Helm, each deployment creates a release version.

Example:

helm install payment ./payment -f values-prod.yaml

creates release version 1.

When you run:

helm upgrade payment ./payment -f values-prod.yaml

Helm creates release version 2, and so on.

Helm keeps track of history for each release so you can rollback.


---

Step 2 — Check Release History

Before rolling back, check the history of your release:

helm history payment

Example output:

REVISION    UPDATED                     STATUS      CHART           APP VERSION     DESCRIPTION
1           Mon Sep 29 08:00:00 2025    deployed    payment-1.0.0   1.0.0           Install complete
2           Tue Sep 30 10:00:00 2025    deployed    payment-1.1.0   1.1.0           Upgrade complete
3           Wed Oct 1 12:00:00 2025     deployed    payment-1.2.0   1.2.0           Upgrade complete

Here:

REVISION = release version number

STATUS = deployed version

DESCRIPTION = install/upgrade description



---

Step 3 — Choose the Version to Rollback

Say your production environment is on revision 3 (payment v1.2.0) and it’s broken.
You want to go back to revision 2.


---

Step 4 — Rollback Command

Run:

helm rollback payment 2

This will:

Revert all Kubernetes resources to the state of revision 2

Deploy v1.1.0 of your payment service



---

Step 5 — Verify the Rollback

Check rollout status:

kubectl rollout status deployment/payment-service

Check Helm release history again:

helm history payment

You should now see:

REVISION    UPDATED                     STATUS      CHART           APP VERSION     DESCRIPTION
1           Mon Sep 29 08:00:00 2025    deployed    payment-1.0.0   1.0.0           Install complete
2           Tue Sep 30 10:00:00 2025    deployed    payment-1.1.0   1.1.0           Upgrade complete
3           Wed Oct 1 12:00:00 2025     deployed    payment-1.2.0   1.2.0           Upgrade complete
4           Thu Oct 2 09:00:00 2025     deployed    payment-1.1.0   1.1.0           Rollback to revision 2

Revision 4 = rollback version.


---

Step 6 — Rollback to a Specific Chart Version

If you want to roll back not just the release state but also a specific chart version, you must pass the chart and values file:

Example:

helm upgrade payment ./payment --version 1.1.0 -f values-prod.yaml


---

⚡ Quick Commands Summary

# Check release history
helm history payment

# Rollback to specific revision
helm rollback payment <revision>

# Check rollout status
kubectl rollout status deployment/payment-service


---

💡 Tip: Helm rollback does not remove the failed release, it creates a new release with the previous configuration.
This means rollbacks are safe and you always have a history to go back to.

Now let's see how helm helps to automate the process of Continuous deployment:


We’ll go step-by-step as shown below :


---

Full Flow — Latest Image Build → Helm → Kubernetes Deployment


---

Step 1 — Developer pushes code

A developer pushes new code to the repository (GitHub, GitLab, etc.).

This triggers a CI/CD pipeline automatically.



---

Step 2 — CI Pipeline builds the Docker image

The CI system (Jenkins, GitHub Actions, GitLab CI, etc.) runs commands like:

docker build -t myrepo/payment-service:$GIT_COMMIT .

Where:

myrepo/payment-service = container repository

$GIT_COMMIT = latest commit hash or build number (unique for every build)


Example:
If commit hash is abc123, image tag = abc123.


---

Step 3 — CI Pipeline pushes image to registry

CI pipeline runs:

docker push myrepo/payment-service:$GIT_COMMIT

Now:

Docker registry has myrepo/payment-service:abc123

Kubernetes can pull this image later.



---

Step 4 — CI/CD pipeline calls Helm with new image tag

Instead of manually editing YAML manifests, CI/CD pipeline runs Helm with the new image tag as a parameter.

Example:

helm upgrade payment ./payment-chart \
  --set image.tag=$GIT_COMMIT \
  -f values-prod.yaml

Here:

--set image.tag=$GIT_COMMIT → tells Helm: “use this latest image tag”

values-prod.yaml → environment-specific configuration (replicas, resources, ingress rules)



---

Step 5 — Helm renders Kubernetes manifests

Inside your Helm chart:

values.yaml contains:


image:
  repository: myrepo/payment-service
  tag: v1.0.0

deployment.yaml contains:


image: "{{ .Values.image.repository }}:{{ .Values.image.tag }}"

Helm takes:

1. Chart templates (deployment.yaml, service.yaml, etc.)


2. Values from values.yaml


3. Overrides from --set (e.g., image.tag=abc123)



Helm renders the final deployment manifest:

image: "myrepo/payment-service:abc123"


---

Step 6 — Helm sends manifests to Kubernetes

Helm runs:

kubectl apply -f <rendered-manifest>

Under the hood, Helm sends the new deployment manifests to the Kubernetes API.

Kubernetes compares the current state of the cluster with the new manifests.


---

Step 7 — Kubernetes performs a rolling update

Since the image tag changed:

Kubernetes pulls the new image (myrepo/payment-service:abc123)

Creates new pods with the updated image

Gradually replaces old pods (rolling update) → no downtime

Verifies health of new pods before removing old ones


Check rollout status:

kubectl rollout status deployment/payment-service


---

Step 8 — Helm stores the new release version

Helm keeps deployment history:

helm history payment

Example output:

REVISION    UPDATED                     STATUS      CHART           APP VERSION     DESCRIPTION
1           Mon Sep 29 08:00:00 2025    deployed    payment-1.0.0   1.0.0           Install complete
2           Wed Oct 1 12:00:00 2025     deployed    payment-1.2.0   1.2.0           Upgrade complete

Each helm upgrade creates a new release revision → easy to rollback if needed.


---

Step 9 — Rollback if needed

If the new version breaks:

helm rollback payment <revision>

Kubernetes reverts to the previous deployment.


---

Final Flow Diagram (Text Version)

Developer pushes code
        ↓
CI builds Docker image → tags it uniquely (e.g., abc123)
        ↓
CI pushes image to container registry
        ↓
CI/CD pipeline calls Helm upgrade with new image tag
        ↓
Helm renders Kubernetes manifests (deployment.yaml, service.yaml, etc.)
        ↓
Helm sends manifests to Kubernetes API
        ↓
Kubernetes performs rolling update with the latest image
        ↓
Helm stores new release version


---

💡 Key advantage:
With Helm + CI/CD:

No manual YAML changes

Fully automated deployments

Easy rollback

Clear tracking of deployments



 